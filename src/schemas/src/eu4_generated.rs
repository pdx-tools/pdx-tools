// automatically generated by the FlatBuffers compiler, do not modify


// @generated

#![allow(
    missing_debug_implementations,
    unused_lifetimes,
    unsafe_op_in_unsafe_fn,
    clippy::all
)]

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rakaly {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod eu_4 {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TERRAIN: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TERRAIN: u8 = 255;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TERRAIN: [Terrain; 20] = [
  Terrain::Grasslands,
  Terrain::Hills,
  Terrain::Mountains,
  Terrain::Desert,
  Terrain::Farmlands,
  Terrain::Forest,
  Terrain::Ocean,
  Terrain::InlandOcean,
  Terrain::CoastalDesert,
  Terrain::Savannah,
  Terrain::Drylands,
  Terrain::Highlands,
  Terrain::Coastline,
  Terrain::Glacier,
  Terrain::ImpassableMountain,
  Terrain::Marsh,
  Terrain::Steppe,
  Terrain::Wasteland,
  Terrain::Jungle,
  Terrain::Woods,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Terrain(pub u8);
#[allow(non_upper_case_globals)]
impl Terrain {
  pub const Grasslands: Self = Self(0);
  pub const Hills: Self = Self(1);
  pub const Mountains: Self = Self(2);
  pub const Desert: Self = Self(3);
  pub const Farmlands: Self = Self(10);
  pub const Forest: Self = Self(12);
  pub const Ocean: Self = Self(15);
  pub const InlandOcean: Self = Self(17);
  pub const CoastalDesert: Self = Self(19);
  pub const Savannah: Self = Self(20);
  pub const Drylands: Self = Self(22);
  pub const Highlands: Self = Self(23);
  pub const Coastline: Self = Self(35);
  pub const Glacier: Self = Self(36);
  pub const ImpassableMountain: Self = Self(37);
  pub const Marsh: Self = Self(38);
  pub const Steppe: Self = Self(39);
  pub const Wasteland: Self = Self(40);
  pub const Jungle: Self = Self(254);
  pub const Woods: Self = Self(255);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 255;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Grasslands,
    Self::Hills,
    Self::Mountains,
    Self::Desert,
    Self::Farmlands,
    Self::Forest,
    Self::Ocean,
    Self::InlandOcean,
    Self::CoastalDesert,
    Self::Savannah,
    Self::Drylands,
    Self::Highlands,
    Self::Coastline,
    Self::Glacier,
    Self::ImpassableMountain,
    Self::Marsh,
    Self::Steppe,
    Self::Wasteland,
    Self::Jungle,
    Self::Woods,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Grasslands => Some("Grasslands"),
      Self::Hills => Some("Hills"),
      Self::Mountains => Some("Mountains"),
      Self::Desert => Some("Desert"),
      Self::Farmlands => Some("Farmlands"),
      Self::Forest => Some("Forest"),
      Self::Ocean => Some("Ocean"),
      Self::InlandOcean => Some("InlandOcean"),
      Self::CoastalDesert => Some("CoastalDesert"),
      Self::Savannah => Some("Savannah"),
      Self::Drylands => Some("Drylands"),
      Self::Highlands => Some("Highlands"),
      Self::Coastline => Some("Coastline"),
      Self::Glacier => Some("Glacier"),
      Self::ImpassableMountain => Some("ImpassableMountain"),
      Self::Marsh => Some("Marsh"),
      Self::Steppe => Some("Steppe"),
      Self::Wasteland => Some("Wasteland"),
      Self::Jungle => Some("Jungle"),
      Self::Woods => Some("Woods"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Terrain {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Terrain {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Terrain {
    type Output = Terrain;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Terrain {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Terrain {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Terrain {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LAND_UNIT_KIND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LAND_UNIT_KIND: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LAND_UNIT_KIND: [LandUnitKind; 3] = [
  LandUnitKind::Infantry,
  LandUnitKind::Cavalry,
  LandUnitKind::Artillery,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LandUnitKind(pub u8);
#[allow(non_upper_case_globals)]
impl LandUnitKind {
  pub const Infantry: Self = Self(0);
  pub const Cavalry: Self = Self(1);
  pub const Artillery: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Infantry,
    Self::Cavalry,
    Self::Artillery,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Infantry => Some("Infantry"),
      Self::Cavalry => Some("Cavalry"),
      Self::Artillery => Some("Artillery"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LandUnitKind {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LandUnitKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LandUnitKind {
    type Output = LandUnitKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LandUnitKind {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LandUnitKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LandUnitKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_NAVAL_UNIT_KIND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_NAVAL_UNIT_KIND: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NAVAL_UNIT_KIND: [NavalUnitKind; 4] = [
  NavalUnitKind::HeavyShip,
  NavalUnitKind::LightShip,
  NavalUnitKind::Galley,
  NavalUnitKind::Transport,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NavalUnitKind(pub u8);
#[allow(non_upper_case_globals)]
impl NavalUnitKind {
  pub const HeavyShip: Self = Self(0);
  pub const LightShip: Self = Self(1);
  pub const Galley: Self = Self(2);
  pub const Transport: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HeavyShip,
    Self::LightShip,
    Self::Galley,
    Self::Transport,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HeavyShip => Some("HeavyShip"),
      Self::LightShip => Some("LightShip"),
      Self::Galley => Some("Galley"),
      Self::Transport => Some("Transport"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for NavalUnitKind {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for NavalUnitKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for NavalUnitKind {
    type Output = NavalUnitKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NavalUnitKind {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for NavalUnitKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for NavalUnitKind {}
// struct Rgb, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Rgb(pub [u8; 3]);
impl Default for Rgb { 
  fn default() -> Self { 
    Self([0; 3])
  }
}
impl core::fmt::Debug for Rgb {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Rgb")
      .field("r", &self.r())
      .field("g", &self.g())
      .field("b", &self.b())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Rgb {}
impl<'a> flatbuffers::Follow<'a> for Rgb {
  type Inner = &'a Rgb;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Rgb>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Rgb {
  type Inner = &'a Rgb;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Rgb>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Rgb {
    type Output = Rgb;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Rgb as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Rgb {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Rgb {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    r: u8,
    g: u8,
    b: u8,
  ) -> Self {
    let mut s = Self([0; 3]);
    s.set_r(r);
    s.set_g(g);
    s.set_b(b);
    s
  }

  pub fn r(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_r(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn g(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[1..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_g(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[1..].as_mut_ptr(),
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum TerrainInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TerrainInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TerrainInfo<'a> {
  type Inner = TerrainInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TerrainInfo<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LOCAL_DEVELOPMENT_COST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TerrainInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TerrainInfoArgs
  ) -> flatbuffers::WIPOffset<TerrainInfo<'bldr>> {
    let mut builder = TerrainInfoBuilder::new(_fbb);
    builder.add_local_development_cost(args.local_development_cost);
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Terrain {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Terrain>(TerrainInfo::VT_ID, Some(Terrain::Grasslands)).unwrap()}
  }
  #[inline]
  pub fn local_development_cost(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TerrainInfo::VT_LOCAL_DEVELOPMENT_COST, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TerrainInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Terrain>("id", Self::VT_ID, false)?
     .visit_field::<f32>("local_development_cost", Self::VT_LOCAL_DEVELOPMENT_COST, false)?
     .finish();
    Ok(())
  }
}
pub struct TerrainInfoArgs {
    pub id: Terrain,
    pub local_development_cost: f32,
}
impl<'a> Default for TerrainInfoArgs {
  #[inline]
  fn default() -> Self {
    TerrainInfoArgs {
      id: Terrain::Grasslands,
      local_development_cost: 0.0,
    }
  }
}

pub struct TerrainInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerrainInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: Terrain) {
    self.fbb_.push_slot::<Terrain>(TerrainInfo::VT_ID, id, Terrain::Grasslands);
  }
  #[inline]
  pub fn add_local_development_cost(&mut self, local_development_cost: f32) {
    self.fbb_.push_slot::<f32>(TerrainInfo::VT_LOCAL_DEVELOPMENT_COST, local_development_cost, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TerrainInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TerrainInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TerrainInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TerrainInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TerrainInfo");
      ds.field("id", &self.id());
      ds.field("local_development_cost", &self.local_development_cost());
      ds.finish()
  }
}
pub enum CountryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Country<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Country<'a> {
  type Inner = Country<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Country<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_ADJECTIVE: flatbuffers::VOffsetT = 8;
  pub const VT_CULTUREGFX: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Country { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CountryArgs<'args>
  ) -> flatbuffers::WIPOffset<Country<'bldr>> {
    let mut builder = CountryBuilder::new(_fbb);
    if let Some(x) = args.culturegfx { builder.add_culturegfx(x); }
    if let Some(x) = args.adjective { builder.add_adjective(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Country::VT_TAG, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Country) -> bool {
    self.tag() < o.tag()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.tag();
    key.cmp(val)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Country::VT_NAME, None)}
  }
  #[inline]
  pub fn adjective(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Country::VT_ADJECTIVE, None)}
  }
  #[inline]
  pub fn culturegfx(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Country::VT_CULTUREGFX, None)}
  }
}

impl flatbuffers::Verifiable for Country<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("adjective", Self::VT_ADJECTIVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("culturegfx", Self::VT_CULTUREGFX, false)?
     .finish();
    Ok(())
  }
}
pub struct CountryArgs<'a> {
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub adjective: Option<flatbuffers::WIPOffset<&'a str>>,
    pub culturegfx: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CountryArgs<'a> {
  #[inline]
  fn default() -> Self {
    CountryArgs {
      tag: None, // required field
      name: None,
      adjective: None,
      culturegfx: None,
    }
  }
}

pub struct CountryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CountryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Country::VT_TAG, tag);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Country::VT_NAME, name);
  }
  #[inline]
  pub fn add_adjective(&mut self, adjective: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Country::VT_ADJECTIVE, adjective);
  }
  #[inline]
  pub fn add_culturegfx(&mut self, culturegfx: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Country::VT_CULTUREGFX, culturegfx);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CountryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CountryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Country<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Country::VT_TAG,"tag");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Country<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Country");
      ds.field("tag", &self.tag());
      ds.field("name", &self.name());
      ds.field("adjective", &self.adjective());
      ds.field("culturegfx", &self.culturegfx());
      ds.finish()
  }
}
pub enum ProvinceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Province<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Province<'a> {
  type Inner = Province<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Province<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TERRAIN: flatbuffers::VOffsetT = 6;
  pub const VT_PROVINCE_IS_ON_AN_ISLAND: flatbuffers::VOffsetT = 8;
  pub const VT_CENTER_X: flatbuffers::VOffsetT = 10;
  pub const VT_CENTER_Y: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Province { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProvinceArgs
  ) -> flatbuffers::WIPOffset<Province<'bldr>> {
    let mut builder = ProvinceBuilder::new(_fbb);
    builder.add_center_y(args.center_y);
    builder.add_center_x(args.center_x);
    builder.add_id(args.id);
    builder.add_province_is_on_an_island(args.province_is_on_an_island);
    builder.add_terrain(args.terrain);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Province::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Province) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u16) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(&val)
  }
  #[inline]
  pub fn terrain(&self) -> Terrain {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Terrain>(Province::VT_TERRAIN, Some(Terrain::Grasslands)).unwrap()}
  }
  #[inline]
  pub fn province_is_on_an_island(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Province::VT_PROVINCE_IS_ON_AN_ISLAND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn center_x(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Province::VT_CENTER_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn center_y(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Province::VT_CENTER_Y, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Province<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("id", Self::VT_ID, false)?
     .visit_field::<Terrain>("terrain", Self::VT_TERRAIN, false)?
     .visit_field::<bool>("province_is_on_an_island", Self::VT_PROVINCE_IS_ON_AN_ISLAND, false)?
     .visit_field::<u16>("center_x", Self::VT_CENTER_X, false)?
     .visit_field::<u16>("center_y", Self::VT_CENTER_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct ProvinceArgs {
    pub id: u16,
    pub terrain: Terrain,
    pub province_is_on_an_island: bool,
    pub center_x: u16,
    pub center_y: u16,
}
impl<'a> Default for ProvinceArgs {
  #[inline]
  fn default() -> Self {
    ProvinceArgs {
      id: 0,
      terrain: Terrain::Grasslands,
      province_is_on_an_island: false,
      center_x: 0,
      center_y: 0,
    }
  }
}

pub struct ProvinceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProvinceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(Province::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_terrain(&mut self, terrain: Terrain) {
    self.fbb_.push_slot::<Terrain>(Province::VT_TERRAIN, terrain, Terrain::Grasslands);
  }
  #[inline]
  pub fn add_province_is_on_an_island(&mut self, province_is_on_an_island: bool) {
    self.fbb_.push_slot::<bool>(Province::VT_PROVINCE_IS_ON_AN_ISLAND, province_is_on_an_island, false);
  }
  #[inline]
  pub fn add_center_x(&mut self, center_x: u16) {
    self.fbb_.push_slot::<u16>(Province::VT_CENTER_X, center_x, 0);
  }
  #[inline]
  pub fn add_center_y(&mut self, center_y: u16) {
    self.fbb_.push_slot::<u16>(Province::VT_CENTER_Y, center_y, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProvinceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProvinceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Province<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Province<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Province");
      ds.field("id", &self.id());
      ds.field("terrain", &self.terrain());
      ds.field("province_is_on_an_island", &self.province_is_on_an_island());
      ds.field("center_x", &self.center_x());
      ds.field("center_y", &self.center_y());
      ds.finish()
  }
}
pub enum EntryUI16ListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntryUI16List<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntryUI16List<'a> {
  type Inner = EntryUI16List<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntryUI16List<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntryUI16List { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EntryUI16ListArgs<'args>
  ) -> flatbuffers::WIPOffset<EntryUI16List<'bldr>> {
    let mut builder = EntryUI16ListBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryUI16List::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &EntryUI16List) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(EntryUI16List::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for EntryUI16List<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct EntryUI16ListArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for EntryUI16ListArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntryUI16ListArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct EntryUI16ListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EntryUI16ListBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryUI16List::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryUI16List::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EntryUI16ListBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EntryUI16ListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntryUI16List<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EntryUI16List::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntryUI16List<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntryUI16List");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum EntryStringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntryString<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntryString<'a> {
  type Inner = EntryString<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntryString<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntryString { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EntryStringArgs<'args>
  ) -> flatbuffers::WIPOffset<EntryString<'bldr>> {
    let mut builder = EntryStringBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryString::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &EntryString) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryString::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for EntryString<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct EntryStringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EntryStringArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntryStringArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct EntryStringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EntryStringBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryString::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryString::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EntryStringBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EntryStringBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntryString<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EntryString::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntryString<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntryString");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum EntryStringListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntryStringList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntryStringList<'a> {
  type Inner = EntryStringList<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntryStringList<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntryStringList { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EntryStringListArgs<'args>
  ) -> flatbuffers::WIPOffset<EntryStringList<'bldr>> {
    let mut builder = EntryStringListBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryStringList::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &EntryStringList) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EntryStringList::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for EntryStringList<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct EntryStringListArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for EntryStringListArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntryStringListArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct EntryStringListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EntryStringListBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryStringList::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryStringList::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EntryStringListBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EntryStringListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntryStringList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EntryStringList::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntryStringList<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntryStringList");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ReligionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Religion<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Religion<'a> {
  type Inner = Religion<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Religion<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_GROUP: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_ALLOWED_CONVERSION: flatbuffers::VOffsetT = 10;
  pub const VT_NEGOTIATE_CONVERT_ON_DOMINANT_RELIGION: flatbuffers::VOffsetT = 12;
  pub const VT_FORCE_CONVERT_ON_BREAK: flatbuffers::VOffsetT = 14;
  pub const VT_COLOR: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Religion { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ReligionArgs<'args>
  ) -> flatbuffers::WIPOffset<Religion<'bldr>> {
    let mut builder = ReligionBuilder::new(_fbb);
    if let Some(x) = args.color { builder.add_color(x); }
    if let Some(x) = args.allowed_conversion { builder.add_allowed_conversion(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.group { builder.add_group(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_force_convert_on_break(args.force_convert_on_break);
    builder.add_negotiate_convert_on_dominant_religion(args.negotiate_convert_on_dominant_religion);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Religion::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Religion) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn group(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Religion::VT_GROUP, None)}
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Religion::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn allowed_conversion(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Religion::VT_ALLOWED_CONVERSION, None)}
  }
  #[inline]
  pub fn negotiate_convert_on_dominant_religion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Religion::VT_NEGOTIATE_CONVERT_ON_DOMINANT_RELIGION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn force_convert_on_break(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Religion::VT_FORCE_CONVERT_ON_BREAK, Some(false)).unwrap()}
  }
  #[inline]
  pub fn color(&self) -> &'a Rgb {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rgb>(Religion::VT_COLOR, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Religion<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("group", Self::VT_GROUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("allowed_conversion", Self::VT_ALLOWED_CONVERSION, false)?
     .visit_field::<bool>("negotiate_convert_on_dominant_religion", Self::VT_NEGOTIATE_CONVERT_ON_DOMINANT_RELIGION, false)?
     .visit_field::<bool>("force_convert_on_break", Self::VT_FORCE_CONVERT_ON_BREAK, false)?
     .visit_field::<Rgb>("color", Self::VT_COLOR, true)?
     .finish();
    Ok(())
  }
}
pub struct ReligionArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub group: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub allowed_conversion: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub negotiate_convert_on_dominant_religion: bool,
    pub force_convert_on_break: bool,
    pub color: Option<&'a Rgb>,
}
impl<'a> Default for ReligionArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReligionArgs {
      key: None, // required field
      group: None,
      name: None, // required field
      allowed_conversion: None,
      negotiate_convert_on_dominant_religion: false,
      force_convert_on_break: false,
      color: None, // required field
    }
  }
}

pub struct ReligionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReligionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Religion::VT_KEY, key);
  }
  #[inline]
  pub fn add_group(&mut self, group: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Religion::VT_GROUP, group);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Religion::VT_NAME, name);
  }
  #[inline]
  pub fn add_allowed_conversion(&mut self, allowed_conversion: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Religion::VT_ALLOWED_CONVERSION, allowed_conversion);
  }
  #[inline]
  pub fn add_negotiate_convert_on_dominant_religion(&mut self, negotiate_convert_on_dominant_religion: bool) {
    self.fbb_.push_slot::<bool>(Religion::VT_NEGOTIATE_CONVERT_ON_DOMINANT_RELIGION, negotiate_convert_on_dominant_religion, false);
  }
  #[inline]
  pub fn add_force_convert_on_break(&mut self, force_convert_on_break: bool) {
    self.fbb_.push_slot::<bool>(Religion::VT_FORCE_CONVERT_ON_BREAK, force_convert_on_break, false);
  }
  #[inline]
  pub fn add_color(&mut self, color: &Rgb) {
    self.fbb_.push_slot_always::<&Rgb>(Religion::VT_COLOR, color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReligionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ReligionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Religion<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Religion::VT_KEY,"key");
    self.fbb_.required(o, Religion::VT_NAME,"name");
    self.fbb_.required(o, Religion::VT_COLOR,"color");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Religion<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Religion");
      ds.field("key", &self.key());
      ds.field("group", &self.group());
      ds.field("name", &self.name());
      ds.field("allowed_conversion", &self.allowed_conversion());
      ds.field("negotiate_convert_on_dominant_religion", &self.negotiate_convert_on_dominant_religion());
      ds.field("force_convert_on_break", &self.force_convert_on_break());
      ds.field("color", &self.color());
      ds.finish()
  }
}
pub enum LandUnitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LandUnit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LandUnit<'a> {
  type Inner = LandUnit<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LandUnit<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_KIND: flatbuffers::VOffsetT = 6;
  pub const VT_MANEUVER: flatbuffers::VOffsetT = 8;
  pub const VT_OFFENSIVE_MORALE: flatbuffers::VOffsetT = 10;
  pub const VT_DEFENSIVE_MORALE: flatbuffers::VOffsetT = 12;
  pub const VT_OFFENSIVE_FIRE: flatbuffers::VOffsetT = 14;
  pub const VT_DEFENSIVE_FIRE: flatbuffers::VOffsetT = 16;
  pub const VT_OFFENSIVE_SHOCK: flatbuffers::VOffsetT = 18;
  pub const VT_DEFENSIVE_SHOCK: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LandUnit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LandUnitArgs<'args>
  ) -> flatbuffers::WIPOffset<LandUnit<'bldr>> {
    let mut builder = LandUnitBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_defensive_shock(args.defensive_shock);
    builder.add_offensive_shock(args.offensive_shock);
    builder.add_defensive_fire(args.defensive_fire);
    builder.add_offensive_fire(args.offensive_fire);
    builder.add_defensive_morale(args.defensive_morale);
    builder.add_offensive_morale(args.offensive_morale);
    builder.add_maneuver(args.maneuver);
    builder.add_kind(args.kind);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LandUnit::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &LandUnit) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn kind(&self) -> LandUnitKind {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LandUnitKind>(LandUnit::VT_KIND, Some(LandUnitKind::Infantry)).unwrap()}
  }
  #[inline]
  pub fn maneuver(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_MANEUVER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offensive_morale(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_OFFENSIVE_MORALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn defensive_morale(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_DEFENSIVE_MORALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offensive_fire(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_OFFENSIVE_FIRE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn defensive_fire(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_DEFENSIVE_FIRE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offensive_shock(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_OFFENSIVE_SHOCK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn defensive_shock(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LandUnit::VT_DEFENSIVE_SHOCK, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LandUnit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<LandUnitKind>("kind", Self::VT_KIND, false)?
     .visit_field::<u8>("maneuver", Self::VT_MANEUVER, false)?
     .visit_field::<u8>("offensive_morale", Self::VT_OFFENSIVE_MORALE, false)?
     .visit_field::<u8>("defensive_morale", Self::VT_DEFENSIVE_MORALE, false)?
     .visit_field::<u8>("offensive_fire", Self::VT_OFFENSIVE_FIRE, false)?
     .visit_field::<u8>("defensive_fire", Self::VT_DEFENSIVE_FIRE, false)?
     .visit_field::<u8>("offensive_shock", Self::VT_OFFENSIVE_SHOCK, false)?
     .visit_field::<u8>("defensive_shock", Self::VT_DEFENSIVE_SHOCK, false)?
     .finish();
    Ok(())
  }
}
pub struct LandUnitArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: LandUnitKind,
    pub maneuver: u8,
    pub offensive_morale: u8,
    pub defensive_morale: u8,
    pub offensive_fire: u8,
    pub defensive_fire: u8,
    pub offensive_shock: u8,
    pub defensive_shock: u8,
}
impl<'a> Default for LandUnitArgs<'a> {
  #[inline]
  fn default() -> Self {
    LandUnitArgs {
      name: None, // required field
      kind: LandUnitKind::Infantry,
      maneuver: 0,
      offensive_morale: 0,
      defensive_morale: 0,
      offensive_fire: 0,
      defensive_fire: 0,
      offensive_shock: 0,
      defensive_shock: 0,
    }
  }
}

pub struct LandUnitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LandUnitBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LandUnit::VT_NAME, name);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: LandUnitKind) {
    self.fbb_.push_slot::<LandUnitKind>(LandUnit::VT_KIND, kind, LandUnitKind::Infantry);
  }
  #[inline]
  pub fn add_maneuver(&mut self, maneuver: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_MANEUVER, maneuver, 0);
  }
  #[inline]
  pub fn add_offensive_morale(&mut self, offensive_morale: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_OFFENSIVE_MORALE, offensive_morale, 0);
  }
  #[inline]
  pub fn add_defensive_morale(&mut self, defensive_morale: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_DEFENSIVE_MORALE, defensive_morale, 0);
  }
  #[inline]
  pub fn add_offensive_fire(&mut self, offensive_fire: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_OFFENSIVE_FIRE, offensive_fire, 0);
  }
  #[inline]
  pub fn add_defensive_fire(&mut self, defensive_fire: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_DEFENSIVE_FIRE, defensive_fire, 0);
  }
  #[inline]
  pub fn add_offensive_shock(&mut self, offensive_shock: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_OFFENSIVE_SHOCK, offensive_shock, 0);
  }
  #[inline]
  pub fn add_defensive_shock(&mut self, defensive_shock: u8) {
    self.fbb_.push_slot::<u8>(LandUnit::VT_DEFENSIVE_SHOCK, defensive_shock, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LandUnitBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LandUnitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LandUnit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LandUnit::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LandUnit<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LandUnit");
      ds.field("name", &self.name());
      ds.field("kind", &self.kind());
      ds.field("maneuver", &self.maneuver());
      ds.field("offensive_morale", &self.offensive_morale());
      ds.field("defensive_morale", &self.defensive_morale());
      ds.field("offensive_fire", &self.offensive_fire());
      ds.field("defensive_fire", &self.defensive_fire());
      ds.field("offensive_shock", &self.offensive_shock());
      ds.field("defensive_shock", &self.defensive_shock());
      ds.finish()
  }
}
pub enum NavalUnitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NavalUnit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NavalUnit<'a> {
  type Inner = NavalUnit<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NavalUnit<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_KIND: flatbuffers::VOffsetT = 6;
  pub const VT_HULL_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_BASE_CANNONS: flatbuffers::VOffsetT = 10;
  pub const VT_BLOCKADE: flatbuffers::VOffsetT = 12;
  pub const VT_SAIL_SPEED: flatbuffers::VOffsetT = 14;
  pub const VT_SAILORS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NavalUnit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NavalUnitArgs<'args>
  ) -> flatbuffers::WIPOffset<NavalUnit<'bldr>> {
    let mut builder = NavalUnitBuilder::new(_fbb);
    builder.add_sail_speed(args.sail_speed);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_sailors(args.sailors);
    builder.add_blockade(args.blockade);
    builder.add_base_cannons(args.base_cannons);
    builder.add_hull_size(args.hull_size);
    builder.add_kind(args.kind);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NavalUnit::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &NavalUnit) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn kind(&self) -> NavalUnitKind {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<NavalUnitKind>(NavalUnit::VT_KIND, Some(NavalUnitKind::HeavyShip)).unwrap()}
  }
  #[inline]
  pub fn hull_size(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NavalUnit::VT_HULL_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn base_cannons(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NavalUnit::VT_BASE_CANNONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn blockade(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NavalUnit::VT_BLOCKADE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sail_speed(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NavalUnit::VT_SAIL_SPEED, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn sailors(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NavalUnit::VT_SAILORS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NavalUnit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<NavalUnitKind>("kind", Self::VT_KIND, false)?
     .visit_field::<u8>("hull_size", Self::VT_HULL_SIZE, false)?
     .visit_field::<u8>("base_cannons", Self::VT_BASE_CANNONS, false)?
     .visit_field::<u8>("blockade", Self::VT_BLOCKADE, false)?
     .visit_field::<f32>("sail_speed", Self::VT_SAIL_SPEED, false)?
     .visit_field::<u16>("sailors", Self::VT_SAILORS, false)?
     .finish();
    Ok(())
  }
}
pub struct NavalUnitArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: NavalUnitKind,
    pub hull_size: u8,
    pub base_cannons: u8,
    pub blockade: u8,
    pub sail_speed: f32,
    pub sailors: u16,
}
impl<'a> Default for NavalUnitArgs<'a> {
  #[inline]
  fn default() -> Self {
    NavalUnitArgs {
      name: None, // required field
      kind: NavalUnitKind::HeavyShip,
      hull_size: 0,
      base_cannons: 0,
      blockade: 0,
      sail_speed: 0.0,
      sailors: 0,
    }
  }
}

pub struct NavalUnitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NavalUnitBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NavalUnit::VT_NAME, name);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: NavalUnitKind) {
    self.fbb_.push_slot::<NavalUnitKind>(NavalUnit::VT_KIND, kind, NavalUnitKind::HeavyShip);
  }
  #[inline]
  pub fn add_hull_size(&mut self, hull_size: u8) {
    self.fbb_.push_slot::<u8>(NavalUnit::VT_HULL_SIZE, hull_size, 0);
  }
  #[inline]
  pub fn add_base_cannons(&mut self, base_cannons: u8) {
    self.fbb_.push_slot::<u8>(NavalUnit::VT_BASE_CANNONS, base_cannons, 0);
  }
  #[inline]
  pub fn add_blockade(&mut self, blockade: u8) {
    self.fbb_.push_slot::<u8>(NavalUnit::VT_BLOCKADE, blockade, 0);
  }
  #[inline]
  pub fn add_sail_speed(&mut self, sail_speed: f32) {
    self.fbb_.push_slot::<f32>(NavalUnit::VT_SAIL_SPEED, sail_speed, 0.0);
  }
  #[inline]
  pub fn add_sailors(&mut self, sailors: u16) {
    self.fbb_.push_slot::<u16>(NavalUnit::VT_SAILORS, sailors, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NavalUnitBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NavalUnitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NavalUnit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, NavalUnit::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NavalUnit<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NavalUnit");
      ds.field("name", &self.name());
      ds.field("kind", &self.kind());
      ds.field("hull_size", &self.hull_size());
      ds.field("base_cannons", &self.base_cannons());
      ds.field("blockade", &self.blockade());
      ds.field("sail_speed", &self.sail_speed());
      ds.field("sailors", &self.sailors());
      ds.finish()
  }
}
pub enum GameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Game<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Game<'a> {
  type Inner = Game<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Game<'a> {
  pub const VT_COUNTRIES: flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL_PROVINCES: flatbuffers::VOffsetT = 6;
  pub const VT_PROVINCES: flatbuffers::VOffsetT = 8;
  pub const VT_LOCALIZATION: flatbuffers::VOffsetT = 10;
  pub const VT_AREAS: flatbuffers::VOffsetT = 12;
  pub const VT_REGIONS: flatbuffers::VOffsetT = 14;
  pub const VT_SUPERREGIONS: flatbuffers::VOffsetT = 16;
  pub const VT_CONTINENTS: flatbuffers::VOffsetT = 18;
  pub const VT_CULTURE_GROUPS: flatbuffers::VOffsetT = 20;
  pub const VT_TRADE_COMPANIES: flatbuffers::VOffsetT = 22;
  pub const VT_PERSONALITIES: flatbuffers::VOffsetT = 24;
  pub const VT_ADVISORS: flatbuffers::VOffsetT = 26;
  pub const VT_RELIGIONS: flatbuffers::VOffsetT = 28;
  pub const VT_LAND_UNITS: flatbuffers::VOffsetT = 30;
  pub const VT_NAVAL_UNITS: flatbuffers::VOffsetT = 32;
  pub const VT_TERRAIN: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Game { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GameArgs<'args>
  ) -> flatbuffers::WIPOffset<Game<'bldr>> {
    let mut builder = GameBuilder::new(_fbb);
    if let Some(x) = args.terrain { builder.add_terrain(x); }
    if let Some(x) = args.naval_units { builder.add_naval_units(x); }
    if let Some(x) = args.land_units { builder.add_land_units(x); }
    if let Some(x) = args.religions { builder.add_religions(x); }
    if let Some(x) = args.advisors { builder.add_advisors(x); }
    if let Some(x) = args.personalities { builder.add_personalities(x); }
    if let Some(x) = args.trade_companies { builder.add_trade_companies(x); }
    if let Some(x) = args.culture_groups { builder.add_culture_groups(x); }
    if let Some(x) = args.continents { builder.add_continents(x); }
    if let Some(x) = args.superregions { builder.add_superregions(x); }
    if let Some(x) = args.regions { builder.add_regions(x); }
    if let Some(x) = args.areas { builder.add_areas(x); }
    if let Some(x) = args.localization { builder.add_localization(x); }
    if let Some(x) = args.provinces { builder.add_provinces(x); }
    builder.add_total_provinces(args.total_provinces);
    if let Some(x) = args.countries { builder.add_countries(x); }
    builder.finish()
  }


  #[inline]
  pub fn countries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Country<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Country>>>>(Game::VT_COUNTRIES, None)}
  }
  /// includes placeholder provinces in count (like 3489)
  #[inline]
  pub fn total_provinces(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Game::VT_TOTAL_PROVINCES, Some(0)).unwrap()}
  }
  /// excludes placholder provinces
  #[inline]
  pub fn provinces(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Province<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Province>>>>(Game::VT_PROVINCES, None)}
  }
  #[inline]
  pub fn localization(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString>>>>(Game::VT_LOCALIZATION, None)}
  }
  #[inline]
  pub fn areas(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryUI16List<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryUI16List>>>>(Game::VT_AREAS, None)}
  }
  #[inline]
  pub fn regions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList>>>>(Game::VT_REGIONS, None)}
  }
  #[inline]
  pub fn superregions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList>>>>(Game::VT_SUPERREGIONS, None)}
  }
  #[inline]
  pub fn continents(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryUI16List<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryUI16List>>>>(Game::VT_CONTINENTS, None)}
  }
  #[inline]
  pub fn culture_groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList>>>>(Game::VT_CULTURE_GROUPS, None)}
  }
  #[inline]
  pub fn trade_companies(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString>>>>(Game::VT_TRADE_COMPANIES, None)}
  }
  #[inline]
  pub fn personalities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString>>>>(Game::VT_PERSONALITIES, None)}
  }
  #[inline]
  pub fn advisors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString>>>>(Game::VT_ADVISORS, None)}
  }
  #[inline]
  pub fn religions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Religion<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Religion>>>>(Game::VT_RELIGIONS, None)}
  }
  #[inline]
  pub fn land_units(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LandUnit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LandUnit>>>>(Game::VT_LAND_UNITS, None)}
  }
  #[inline]
  pub fn naval_units(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NavalUnit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NavalUnit>>>>(Game::VT_NAVAL_UNITS, None)}
  }
  #[inline]
  pub fn terrain(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainInfo>>>>(Game::VT_TERRAIN, None)}
  }
}

impl flatbuffers::Verifiable for Game<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Country>>>>("countries", Self::VT_COUNTRIES, false)?
     .visit_field::<u32>("total_provinces", Self::VT_TOTAL_PROVINCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Province>>>>("provinces", Self::VT_PROVINCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryString>>>>("localization", Self::VT_LOCALIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryUI16List>>>>("areas", Self::VT_AREAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryStringList>>>>("regions", Self::VT_REGIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryStringList>>>>("superregions", Self::VT_SUPERREGIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryUI16List>>>>("continents", Self::VT_CONTINENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryStringList>>>>("culture_groups", Self::VT_CULTURE_GROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryString>>>>("trade_companies", Self::VT_TRADE_COMPANIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryString>>>>("personalities", Self::VT_PERSONALITIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryString>>>>("advisors", Self::VT_ADVISORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Religion>>>>("religions", Self::VT_RELIGIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LandUnit>>>>("land_units", Self::VT_LAND_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NavalUnit>>>>("naval_units", Self::VT_NAVAL_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TerrainInfo>>>>("terrain", Self::VT_TERRAIN, false)?
     .finish();
    Ok(())
  }
}
pub struct GameArgs<'a> {
    pub countries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Country<'a>>>>>,
    pub total_provinces: u32,
    pub provinces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Province<'a>>>>>,
    pub localization: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>>>,
    pub areas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryUI16List<'a>>>>>,
    pub regions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList<'a>>>>>,
    pub superregions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList<'a>>>>>,
    pub continents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryUI16List<'a>>>>>,
    pub culture_groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryStringList<'a>>>>>,
    pub trade_companies: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>>>,
    pub personalities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>>>,
    pub advisors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryString<'a>>>>>,
    pub religions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Religion<'a>>>>>,
    pub land_units: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LandUnit<'a>>>>>,
    pub naval_units: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NavalUnit<'a>>>>>,
    pub terrain: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainInfo<'a>>>>>,
}
impl<'a> Default for GameArgs<'a> {
  #[inline]
  fn default() -> Self {
    GameArgs {
      countries: None,
      total_provinces: 0,
      provinces: None,
      localization: None,
      areas: None,
      regions: None,
      superregions: None,
      continents: None,
      culture_groups: None,
      trade_companies: None,
      personalities: None,
      advisors: None,
      religions: None,
      land_units: None,
      naval_units: None,
      terrain: None,
    }
  }
}

pub struct GameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GameBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_countries(&mut self, countries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Country<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_COUNTRIES, countries);
  }
  #[inline]
  pub fn add_total_provinces(&mut self, total_provinces: u32) {
    self.fbb_.push_slot::<u32>(Game::VT_TOTAL_PROVINCES, total_provinces, 0);
  }
  #[inline]
  pub fn add_provinces(&mut self, provinces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Province<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_PROVINCES, provinces);
  }
  #[inline]
  pub fn add_localization(&mut self, localization: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryString<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_LOCALIZATION, localization);
  }
  #[inline]
  pub fn add_areas(&mut self, areas: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryUI16List<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_AREAS, areas);
  }
  #[inline]
  pub fn add_regions(&mut self, regions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryStringList<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_REGIONS, regions);
  }
  #[inline]
  pub fn add_superregions(&mut self, superregions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryStringList<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_SUPERREGIONS, superregions);
  }
  #[inline]
  pub fn add_continents(&mut self, continents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryUI16List<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_CONTINENTS, continents);
  }
  #[inline]
  pub fn add_culture_groups(&mut self, culture_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryStringList<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_CULTURE_GROUPS, culture_groups);
  }
  #[inline]
  pub fn add_trade_companies(&mut self, trade_companies: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryString<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_TRADE_COMPANIES, trade_companies);
  }
  #[inline]
  pub fn add_personalities(&mut self, personalities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryString<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_PERSONALITIES, personalities);
  }
  #[inline]
  pub fn add_advisors(&mut self, advisors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryString<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_ADVISORS, advisors);
  }
  #[inline]
  pub fn add_religions(&mut self, religions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Religion<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_RELIGIONS, religions);
  }
  #[inline]
  pub fn add_land_units(&mut self, land_units: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LandUnit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_LAND_UNITS, land_units);
  }
  #[inline]
  pub fn add_naval_units(&mut self, naval_units: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NavalUnit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_NAVAL_UNITS, naval_units);
  }
  #[inline]
  pub fn add_terrain(&mut self, terrain: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TerrainInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Game::VT_TERRAIN, terrain);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Game<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Game<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Game");
      ds.field("countries", &self.countries());
      ds.field("total_provinces", &self.total_provinces());
      ds.field("provinces", &self.provinces());
      ds.field("localization", &self.localization());
      ds.field("areas", &self.areas());
      ds.field("regions", &self.regions());
      ds.field("superregions", &self.superregions());
      ds.field("continents", &self.continents());
      ds.field("culture_groups", &self.culture_groups());
      ds.field("trade_companies", &self.trade_companies());
      ds.field("personalities", &self.personalities());
      ds.field("advisors", &self.advisors());
      ds.field("religions", &self.religions());
      ds.field("land_units", &self.land_units());
      ds.field("naval_units", &self.naval_units());
      ds.field("terrain", &self.terrain());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Game`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_game_unchecked`.
pub fn root_as_game(buf: &[u8]) -> Result<Game, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Game>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Game` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_game_unchecked`.
pub fn size_prefixed_root_as_game(buf: &[u8]) -> Result<Game, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Game>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Game` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_game_unchecked`.
pub fn root_as_game_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Game<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Game<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Game` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_game_unchecked`.
pub fn size_prefixed_root_as_game_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Game<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Game<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Game and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Game`.
pub unsafe fn root_as_game_unchecked(buf: &[u8]) -> Game {
  flatbuffers::root_unchecked::<Game>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Game and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Game`.
pub unsafe fn size_prefixed_root_as_game_unchecked(buf: &[u8]) -> Game {
  flatbuffers::size_prefixed_root_unchecked::<Game>(buf)
}
#[inline]
pub fn finish_game_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Game<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_game_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Game<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Eu4
}  // pub mod Rakaly

